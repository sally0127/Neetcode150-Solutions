**Depth of Binary Tree**
-
🔗 Link: Depth of Binary Tree

💡 Difficulty: Easy

🛠️ Topics: Binary Tree、Depth Calculation、Traversal Methods、Loops and Recursion、Data Structure Application

===============================================

Given the root of a binary tree, return its depth.

The depth of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.

Example 1:

Input: root = [1,2,3,null,null,4]
Output: 3

Example 2:

Input: root = []
Output: 0

Constraints:

．0 <= The number of nodes in the tree <= 100.

．-100 <= Node.val <= 100

=========================================================

**UMPIRE Method:**

**Understand**

1.目標：我們要找的是「二元樹的深度」，也就是從根節點（根）到最遠的葉子節點的最長路徑上的節點數量。

2.定義：樹的深度就是那條「最長的路徑」上，有多少個節點。

3.假設：

  ．每個節點可能有 0 個、1 個或 2 個子節點。
  
  ．如果樹是空的（根節點是空），深度就是 0。

**Match**

我們可以找一些常用的解法來解這個問題：

1.遞迴方法：

    ．用遞迴的方式來算每個子樹的深度，最後加總。每個節點的深度就是它的左右子樹的最大深度再加一。
    
    ．基本公式：depth(node) = 1 + max(depth(node.left), depth(node.right))。

2.迭代方法：

    ．可以用「廣度優先搜尋（BFS）」或「深度優先搜尋（DFS）」來解。
    
    ．用 BFS 可以一層一層來看，每遍歷一層就加一次深度計數器。

**Plan**

1.遞迴的方法:

    步驟：
    
    ．從根節點開始，如果節點是空的，回傳深度 0。
    
    ．如果節點不是空的，分別算出左右子樹的深度。
    
    ．然後回傳左右子樹中較大的深度再加一。

2.「廣度優先搜尋」（BFS）(使用迭代)方法:

     步驟:

      ．檢查 root 是否為空。如果是空樹，直接返回深度為 0。
      
      ．初始化 queue 佇列，並將 root 節點放進去。初始化 depth = 0。
      
      ．當 queue 不為空時，說明還有節點需要處理，繼續進行 while 迴圈。
      
      ．level_size 記錄目前這一層的節點數（即佇列中節點數），用來確定要處理多少節點。
      
      ．使用 for 迴圈來逐一處理當前層的所有節點。
      
      ．對於當前節點，如果有左右子節點，將它們加入 queue 中，以便在下一層 while 迴圈中處理。
      
      ．當這一層的所有節點都處理完，depth 加一，表示走完一層。
      
      ．當 queue 中節點都處理完畢後，返回 depth，即為二元樹的最大深度。

3.兩種方法不同點

1. 遞迴方法 (DFS)

．處理邏輯：使用「深度優先搜尋 (Depth-First Search, DFS)」，遞迴方式會讓函數一路深入到樹的最底層，然後再從最底層逐層返回深度。

．運作方式：從根節點開始，每次遞迴都進入左右子樹，直到碰到葉子節點（沒有子節點的節點），然後回傳深度值。

．特點：實現簡單，程式碼也很直觀，但使用遞迴時需要考慮遞迴深度的問題，對於特別深的樹可能會有遞迴限制。

2. BFS 方法 (使用迭代)

．處理邏輯：使用「廣度優先搜尋 (Breadth-First Search, BFS)」，逐層往下遍歷每一層節點。

．運作方式：從根節點開始，使用佇列來儲存每一層的節點。每處理完一層就把深度加一，直到處理完所有層。

．特點：BFS 不用擔心遞迴深度問題，因此更適合非常深或不平衡的樹。雖然 BFS 的空間需求可能更高，因為需要儲存每一層的所有節點，但能更直觀地從上到下計算深度。

總結比較

．遞迴 (DFS)：適合處理一般深度適中的樹，邏輯清晰。

．BFS (迭代)：適合更深或不平衡的樹，直接從上往下逐層處理。

在遞迴算法中，儘管計算過程是「先往下遞迴到最底層再往上回傳深度」，但結果其實是計算從根節點開始的路徑長度。這種方式的本質還是從根往下算，只是處理方式是先到底層，然後再一層一層地回傳深度值。

如果我們用 BFS 或層次遍歷的方法，則可以更加直觀地「從根開始，逐層往下」累加深度。

**Implement**

see solution.py

**Review**

測試邊界情況：

    ．空的樹：應該回傳 0。
    
    ．只有一個節點的樹：應該回傳 1。
    
    ．左邊或右邊子樹是空的：這個情況程式應該要正常處理。
    
    ．完全二元樹：比如高度為 3 的樹，回傳結果應該是 3。
    
    ．不平衡的樹：左或右子樹高度差很多的情況。

**Evaluate**

．時間複雜度：O(N)，N 是節點數量。每個節點都會被訪問一次。

．空間複雜度：O(H)，H 是樹的高度，這是遞迴時的最大深度。

