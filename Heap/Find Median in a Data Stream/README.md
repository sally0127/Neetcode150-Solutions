**Find Median in a Data Stream**
-

🔗 Link: Find Median in a Data Stream

💡 Difficulty: Hard

🛠️ Topics: Heap (堆)、Two Heaps (雙堆結構)、Data Stream (資料流)、Priority Queue (優先佇列)、Dynamic Data Structures (動態數據結構)、Time Complexity (時間複雜度)、

 Space Complexity(空間複雜度)

這些觀念反映出題目設計的核心：如何設計一個能持續、高效地處理資料流的數據結構，並在動態變化中快速查詢關鍵值（中位數）。

==========================================

The median is the middle value in a sorted list of integers. For lists of even length, there is no middle value, so the median is the mean of the two middle values.

For example:

    ．For arr = [1,2,3], the median is 2.
    
    ．For arr = [1,2], the median is (1 + 2) / 2 = 1.5

Implement the MedianFinder class:

    ．MedianFinder() initializes the MedianFinder object.
    
    ．void addNum(int num) adds the integer num from the data stream to the data structure.
    
    ．double findMedian() returns the median of all elements so far.

Example 1:

Input:
["MedianFinder", "addNum", "1", "findMedian", "addNum", "3" "findMedian", "addNum", "2", "findMedian"]

Output:
[null, null, 1.0, null, 2.0, null, 2.0]

Explanation:
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.findMedian(); // return 1.0
medianFinder.addNum(3);    // arr = [1, 3]
medianFinder.findMedian(); // return 2.0
medianFinder.addNum(2);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0

Constraints:

．-100,000 <= num <= 100,000

．findMedian will only be called after adding at least one integer to the data structure.

===========================================
**UMPIRE Method:**

**Understand**

1.找出中位數的核心：

  ．中位數 是有序數列的中間值：

    ．如果數列長度為奇數，返回中間的數。
    
    ．如果數列長度為偶數，返回中間兩數的平均值。

  ．動態數據流的特點：數據會不斷新增，必須支持高效的插入與中位數計算。

2.功能說明：

  ．MedianFinder(): 初始化數據結構。
  
  ．addNum(int num): 插入一個整數 num 到數據流中。
  
  ．findMedian(): 計算並返回當前數據流的中位數。

3.目標：在 高效性（時間與空間複雜度） 和 正確性（維護排序） 之間取得平衡。

**Match**

可以考慮的解法：

1.暴力法：

    ．使用列表存儲數據，每次插入後排序。
    
    ．計算中位數時直接獲取中間元素或平均值。
    
    ．缺點：插入操作效率低，排序為 O(nlogn)。

2.優化法：

．使用 兩個堆（Heaps）：
  
  ．最大堆 low：存儲數據流中較小的一半。
  
  ．最小堆 high：存儲數據流中較大的一半。
  
  ．保持兩個堆的平衡：

    ．最大堆元素數量 ≥ 最小堆。
    
    ．中位數由堆頂元素直接計算。

  ．插入與計算中位數的時間複雜度為 O(logn)。

**Plan**

1.初始化：

    ．使用 heapq 模擬最大堆（取負值存入）。
    
    ．初始化兩個堆 low 和 high。

2.插入數據：

    ．插入 num 時，先放入 low（最大堆）。
    
    ．再將 low 的堆頂移入 high（最小堆），維持排序。
    
    ．最後平衡兩個堆的大小。

3.計算中位數：

    ．如果 low 的大小大於 high，返回 low 的堆頂。
    
    ．否則返回兩個堆頂的平均值。

**Implement**

see solution.py

**Review**

1.初始化：

    ．最大堆和最小堆都正確初始化。
    
    ．維護兩個堆的平衡性。

2.插入操作：
    
    ．插入後確保最大堆的堆頂始終小於最小堆的堆頂。
    
    ．保證兩個堆的大小差不超過 1。

3.計算中位數：

    ．最大堆比最小堆多一個元素時，直接返回最大堆堆頂。
    
    ．堆大小相等時，計算兩堆堆頂的平均值。

**Evaluate**

．時間複雜度：

    ．插入數據：O(logn)，因為堆操作需要 O(logn) 時間。
    
    ．查詢中位數：O(1)，因為堆頂元素可直接訪問。

．空間複雜度：O(n)，需要存儲所有數據於兩個堆中。

**具體步驟拆解**

1. 初始化

．使用 heapq 建立兩個堆：

    ．最大堆 low 存放負數，實現從大到小的排序。
    
    ．最小堆 high 存放正數，實現從小到大的排序。

2. 插入數據的邏輯

每次插入一個新數據 num 時：

1.Step 1：先放入最大堆 low（暫時處理所有新數據）

    ．我們將新數據的負數加入最大堆（因為 heapq 只支持最小堆，加入負數模擬最大堆）。
    
    ．這樣保證了 low 的堆頂是「目前較小數據的一部分中的最大值」。

例子：

  ．插入數據 3，最大堆變為 [-3]。

2.Step 2：將最大堆的堆頂移到最小堆

    ．因為新的數據先加入了最大堆，最大堆的堆頂可能比最小堆的堆頂大，這會破壞兩堆的順序。
    
    ．所以我們取出最大堆的堆頂（注意是負數的相反值），放入最小堆，確保兩堆的數據是按順序排列的。

例子：

    ．插入數據 3，最大堆為 [-3]，最小堆為空。
    
    ．將 -(-3) 加入最小堆後：

      ．最大堆變為空，最小堆變為 [3]。

3.Step 3：平衡兩個堆的大小

    ．如果最小堆的大小超過最大堆，將最小堆的堆頂移回最大堆。
    
    ．保證兩堆大小相差不超過 1。

例子：

    ．插入數據 5：

      ．最大堆為 [-3]，最小堆為 [5]。
      
      ．平衡後，最大堆為 [-3]，最小堆為 [5]（大小已平衡）。

3. 計算中位數的邏輯

．最大堆和最小堆大小可能有以下兩種情況：

    1.最大堆比最小堆多 1 個元素（奇數情況）：

      ．中位數是最大堆的堆頂，即「較小數據的一半中最大的值」。

    2.兩個堆大小相等（偶數情況）：

      ．中位數是兩個堆堆頂的平均值。

例子：

1.數據流 [1, 2, 3]：

    ．最大堆 [-2, -1]，最小堆 [3]。
    
    ．中位數為 2（最大堆堆頂）。

2.數據流 [1, 2, 3, 4]：

    ．最大堆 [-2, -1]，最小堆 [3, 4]。
    
    ．中位數為 (2 + 3) / 2 = 2.5。

**核心邏輯總結**

1.用兩個堆分治數據流：

    ．最大堆存放「較小的一半」，最小堆存放「較大的一半」。

2.保持兩個堆的平衡性：

    ．兩個堆的大小相差不超過 1。

3.高效計算中位數：

    ．根據堆頂元素直接得出中位數，無需排序。

這樣，我們能以 O(log n) 插入數據，並以 O(1) 計算中位數！

**為什麼要用負數模擬最大堆？**

Python 的 heapq 是 最小堆 的實現，主要用於快速取出最小值。然而，在某些場景中需要 最大堆（快速取最大值）。為了避免重寫堆的邏輯，我們可以利用 數字取負 的技巧來模擬最大堆。

以下是原因與詳細解釋：

1.heapq 的特性：

    ．heapq 默認是最小堆，堆頂元素是堆中最小的數值。
    
    ．如果我們直接使用最小堆，只能快速獲取最小值，無法快速獲取最大值。

2.數字取負的效果：

    ．假設數列為 [3, 1, 5]，如果直接存入 heapq，最小值是 1。
    
    ．如果改存取負後的值 [-3, -1, -5]：

        ．負數中最小值是 -5，它對應的原始數值其實是 5（最大值）。
        
        ．取堆頂元素時再轉回正數（即取負數的相反值），即可得到最大值。

3.避免重新實現堆：

    ．heapq 是高效的堆實現（基於二叉堆），直接使用它比重新設計和實現一個最大堆更簡單和高效。

4.節省時間與空間：

    ．使用數字取負的技巧，只需在存取堆元素時稍作處理，運行效率與直接操作最大堆幾乎一致。
    
    ．避免增加額外的數據結構或複雜的代碼邏輯。

**模擬最大堆的具體操作**

假設我們有一個數組 [3, 1, 5]，並希望用 heapq 模擬最大堆：

1.插入數字（取負數）：

    ．插入 3：存 -3，堆為 [-3]。
    
    ．插入 1：存 -1，堆為 [-3, -1]（堆頂為最大值的負數 -3）。
    
    ．插入 5：存 -5，堆為 [-5, -1, -3]（堆頂為最大值的負數 -5）。

2.取出最大值：

    ．取堆頂元素：-5。
    
    ．轉回正數：5（即原始數據中的最大值）。

3.堆的變化過程：

    ．插入順序：3 → 1 → 5。
    
    ．堆內部結構（負數形式）：[-3] → [-3, -1] → [-5, -1, -3]。
    
    ．對應的原始數據（正數形式）：[3] → [3, 1] → [5, 1, 3]。

 **總結**

- `heapq` 默認支持最小堆，使用負數模擬最大堆，是為了：

  1. 利用現有的高效實現。

  2. 避免增加額外的邏輯複雜度。

- 在存入數字時取負數，取出時再轉回正數即可實現最大堆功能。

- 這是一種簡單高效的解決方案，常見於需要同時操作最小堆與最大堆的場景（如中位數數據流問題）。

