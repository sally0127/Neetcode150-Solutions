**Permutations**
-
🔗 Link: Permutations

💡 Difficulty: Medium

🛠️ Topics: Backtracking（回溯法）、Permutations（排列）和 Combinations（組合）的區別、遞歸深度控制與解的構建、空間與時間複雜度分析、狀態管理與剪枝

=================================

Given an array nums of unique integers, return all the possible permutations. You may return the answer in any order.

Example 1:

Input: nums = [1,2,3]

Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

Example 2:

Input: nums = [7]

Output: [[7]]

Constraints:

．1 <= nums.length <= 6

．-10 <= nums[i] <= 10

=============================================

**UMPIRE Method:**

**Understand**

題目需求：

1.輸入：

．一個整數數組 nums，所有數字均為顯著的整數。

2.輸出：

．返回所有可能的排列，每種排列的順序不同。

．結果可以按任意順序返回。

題目例子：

．nums = [1, 2, 3]

    ．輸出：[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]

．nums = [0, 1]

    ．輸出：[[0, 1], [1, 0]]

理解關鍵：

．需要生成所有排列（排列的數量為 n!，其中 n 是數組的長度）。

．必須確保每個排列都唯一，且數字使用完所有數組中的元素。

**Match**

這題可以用 回溯法 (Backtracking) 來解決，因為：

1.每個排列可以看成一棵遞歸樹，回溯法天然適合生成這樣的組合。

2.需要逐步選擇數字並記錄已用數字，確保不重複選擇。

3.需要在遍歷到完整排列後記錄結果，並在回溯時清除選擇。

**Plan**

1.定義結果列表： 用 res 儲存所有排列結果。

2.設計回溯函數：

．參數：

    ．path：當前排列路徑。
    
    ．used：布林數組，用來標記哪些數字已被選用。

．終止條件：

    ．當 path 的長度等於 nums 的長度時，表示一個完整排列，將其加入 res。

．遞歸邏輯：

    ．遍歷 nums 的每個數字。
    
    ．如果數字未被使用，則：

        1.標記為已使用。
        
        2.加入當前路徑 path。
        
        3.遞歸生成下一層排列。
        
        4.回溯時移除數字並標記為未使用。

3.執行回溯： 初始條件為空的 path 和所有數字未被使用的狀態。

4.返回結果： 回溯結束後，返回 res。

**Implement**

see solution.py

**Review**

1.正確性檢查：

  ．確保輸出包含所有排列，且排列中無重複項目。
        
  ．測試用例：

      ．空數組：nums = []，輸出應為 [[]]。
      
      ．單元素：nums = [1]，輸出應為 [[1]]。
      
      ．多元素：nums = [1, 2, 3]，輸出應為 6 種排列。

2.手動驗算：

    ．確認生成的排列符合數學規則，每個排列長度等於輸入長度，排列的總數為 n!。

**Evaluate**

1.時間複雜度：

  ．有 n! 種排列，每次複製 path 時需要 O(n)，因此總時間複雜度為 O(n * n!)（生成排列 + 複製路徑）。

2.空間複雜度：

  ．遞歸深度最多為 n，path 和 used 的空間需求為 O(n)，因此空間複雜度為 O(n)（遞歸堆疊 + 狀態標記）。
